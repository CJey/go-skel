package context

import (
	gcontext "context"
	"net"
	"reflect"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/satori/go.uuid"
	"go.uber.org/zap"
)

type CancelFunc gcontext.CancelFunc

// context的本意是希望可以参考golang官方context包
// 并能额外提供一些更加便捷的操作方式
type Context struct {
	sync.RWMutex

	ctx    gcontext.Context
	parent *Context
	// name will be set as zap logger's name
	// if a new sub context generated by method New()
	// the new one will has a sequantialed suffix number after it's name
	name    string
	session string
	// 串联所有的at，表明自身当前所处的具名位置
	// 在zap的日志中出现在名为@的field中
	where string
	// always original logger
	logger *zap.SugaredLogger

	track  *uint64
	values map[interface{}]interface{}

	L *zap.SugaredLogger
}

var (
	BootID   = uuid.NewV4().String()
	BootTime = time.Now()
)

var (
	counter uint64 = 0
)

func New(at ...string) *Context {
	return NewWith(gcontext.Background(), at...)
}

// use a uuid as name, with sequantial encoding
func NewWith(ctx gcontext.Context, at ...string) *Context {
	const h = "000000000000"
	seq := atomic.AddUint64(&counter, 1)
	a := strconv.Itoa(int(seq))
	return Named(ctx, BootID[:24]+h[:12-len(a)]+a, at...)
}

func Background(name string, at ...string) *Context {
	return Named(gcontext.Background(), name, at...)
}

func Named(ctx gcontext.Context, name string, at ...string) *Context {
	var t uint64 = 0
	var w string
	if len(at) > 0 && at[0] != "" {
		w = at[0]
	}
	logger := zap.S()
	c := &Context{
		ctx:    ctx,
		parent: nil,
		name:   name,
		where:  w,
		logger: logger,

		track:  &t,
		values: map[interface{}]interface{}{},

		L: logger,
	}

	c.L = c.logger.Named(c.name)
	if c.where != "" {
		c.L = c.L.With("@", c.where)
	}
	return c
}

// ~=copy
func (c *Context) shadow() *Context {
	return &Context{
		L: c.L,

		ctx:     c.ctx,
		parent:  c,
		name:    c.name,
		session: c.session,
		where:   c.where,
		logger:  c.logger,

		track:  c.track,
		values: map[interface{}]interface{}{},
	}
}

// Context派生子Context，用于并发派生新goroutine的场景
// 比如内部api基本上都采用了并发调用的方式，需要一个额外的追踪标记来标明日志的从属请求
func (c *Context) New(at ...string) *Context {
	var t uint64 = 0
	shadow := c.shadow()
	shadow.track = &t

	// 保留ctx，应用新name
	seq := atomic.AddUint64(c.track, 1)
	if shadow.name == "" {
		shadow.name = strconv.Itoa(int(seq))
	} else {
		shadow.name += "." + strconv.Itoa(int(seq))
	}
	if shadow.session != "" {
		shadow.session += "." + strconv.Itoa(int(seq))
	}

	if len(at) > 0 && at[0] != "" {
		if shadow.where == "" {
			shadow.where = at[0]
		} else {
			shadow.where += "." + at[0]
		}
	}

	shadow.L = shadow.logger.Named(shadow.name)
	if shadow.where != "" {
		shadow.L = shadow.L.With("@", shadow.where)
	}

	return shadow
}

// 用于标记当前位置，或者传达调用路径时使用
func (c *Context) At(at string) *Context {
	shadow := c.shadow()

	if at != "" {
		if shadow.where == "" {
			shadow.where = at
		} else {
			shadow.where += "." + at
		}
	}

	shadow.L = shadow.logger.Named(shadow.name)
	if shadow.where != "" {
		shadow.L = shadow.L.With("@", shadow.where)
	}
	return shadow
}

func (c *Context) Name() string {
	return c.name
}

func (c *Context) Session(s ...string) string {
	if len(s) > 0 {
		c.session = s[0]
	}

	if c.session == "" {
		return c.name
	}

	return c.session
}

func (c *Context) WithCancel() (*Context, CancelFunc) {
	shadow := c.shadow()

	// 保留name，应用新ctx
	ctx, f := gcontext.WithCancel(shadow.ctx)
	shadow.ctx = ctx

	return shadow, CancelFunc(f)
}

func (c *Context) WithDeadline(d time.Time) (*Context, CancelFunc) {
	shadow := c.shadow()

	// 保留name，应用新ctx
	ctx, f := gcontext.WithDeadline(shadow.ctx, d)
	shadow.ctx = ctx

	return shadow, CancelFunc(f)
}

func (c *Context) WithTimeout(timeout time.Duration) (*Context, CancelFunc) {
	shadow := c.shadow()

	// 保留session，应用新ctx
	ctx, f := gcontext.WithTimeout(shadow.ctx, timeout)
	shadow.ctx = ctx

	return shadow, CancelFunc(f)
}

func (c *Context) WithValue(key, val interface{}) *Context {
	shadow := c.shadow()

	// 保留session，应用新ctx
	ctx := gcontext.WithValue(shadow.ctx, key, val)
	shadow.ctx = ctx

	return shadow
}

func (c *Context) Deadline() (deadline time.Time, ok bool) {
	return c.ctx.Deadline()
}

func (c *Context) Done() <-chan struct{} {
	return c.ctx.Done()
}

func (c *Context) Err() error {
	return c.ctx.Err()
}

func (c *Context) Value(key interface{}) interface{} {
	return c.ctx.Value(key)
}

func (c *Context) Add(key interface{}, value interface{}) {
	if key == nil {
		panic("nil key")
	}
	if !reflect.TypeOf(key).Comparable() {
		panic("key is not comparable")
	}

	c.Lock()
	defer c.Unlock()
	val, ok := c.values[key]
	if ok {
		if vals, ok := val.([]interface{}); ok {
			c.values[key] = append(vals, value)
			return
		}
	}
	c.values[key] = []interface{}{val}
}

func (c *Context) GetSlice(key interface{}) []interface{} {
	if val, ok := c.Get(key); ok {
		return val.([]interface{})
	}
	return nil
}

func (c *Context) Set(key interface{}, value interface{}) {
	if key == nil {
		panic("nil key")
	}
	if !reflect.TypeOf(key).Comparable() {
		panic("key is not comparable")
	}

	c.Lock()
	c.values[key] = value
	c.Unlock()
}

func (c *Context) Get(key interface{}) (interface{}, bool) {
	c.RLock()
	val, ok := c.values[key]
	c.RUnlock()
	if !ok && c.parent != nil {
		return c.parent.Get(key)
	}
	return val, ok
}

func (c *Context) Has(key interface{}) bool {
	_, ok := c.Get(key)
	return ok
}

func (c *Context) Del(key interface{}) {
	c.Lock()
	delete(c.values, key)
	c.Unlock()
}

func (c *Context) GetString(key interface{}) string {
	if val, ok := c.Get(key); ok {
		return val.(string)
	}
	return ""
}

func (c *Context) GetInt(key interface{}) int {
	if val, ok := c.Get(key); ok {
		return val.(int)
	}
	return 0
}

func (c *Context) GetInt64(key interface{}) int64 {
	if val, ok := c.Get(key); ok {
		return val.(int64)
	}
	return 0
}

func (c *Context) GetUint(key interface{}) uint {
	if val, ok := c.Get(key); ok {
		return val.(uint)
	}
	return 0
}

func (c *Context) GetUint64(key interface{}) uint64 {
	if val, ok := c.Get(key); ok {
		return val.(uint64)
	}
	return 0
}

func (c *Context) GetFloat32(key interface{}) float32 {
	if val, ok := c.Get(key); ok {
		return val.(float32)
	}
	return 0
}

func (c *Context) GetFloat64(key interface{}) float64 {
	if val, ok := c.Get(key); ok {
		return val.(float64)
	}
	return 0
}

func (c *Context) GetBool(key interface{}) bool {
	if val, ok := c.Get(key); ok {
		return val.(bool)
	}
	return false
}

func (c *Context) GetBytes(key interface{}) []byte {
	if val, ok := c.Get(key); ok {
		return val.([]byte)
	}
	return nil
}

func (c *Context) GetTime(key interface{}) time.Time {
	if val, ok := c.Get(key); ok {
		return val.(time.Time)
	}
	return time.Time{}
}

func (c *Context) GetDuration(key interface{}) time.Duration {
	if val, ok := c.Get(key); ok {
		return val.(time.Duration)
	}
	return 0
}

func (c *Context) GetAddr(key interface{}) net.Addr {
	if val, ok := c.Get(key); ok {
		return val.(net.Addr)
	}
	return nil
}

func (c *Context) GetIP(key interface{}) net.IP {
	if val, ok := c.Get(key); ok {
		return val.(net.IP)
	}
	return nil
}
