#! /bin/sh

DEFAULT_APP={=APPNAME=}
DEFAULT_PKG=main

# _ROOT: 工作目录
# ROOT: 总是正确指向build脚本所在目录
_ROOT="$(pwd)" && cd "$(dirname "$0")" && ROOT="$(pwd)"

UNAME=$(uname)

hash() {
    if [ $UNAME = "Darwin" ]; then
        shasum $*
    else
        sha1sum $*
    fi
}

# 支持软连接的方式调用此脚本 (软连接的判断需要移除目录部分)，自动编译并执行
# 软连接的文件名称即为待编译的包名称 (或预定义的项目名称)
# 如果有多个main包可以编译，简单的做多个软连接即可
__softlink() {
    _d="$(dirname "$1")"
    _f="$(basename "$1")"
    cd "$_ROOT" && cd "$_d"
    if [ -L "$_f" ]; then
        ROOT="$(dirname "$(pwd -P)/$(readlink -- "$_f")")"
        APPNAME="$_f"
        flag_run=1
    else
        if [ -n "$2" ]; then
            APPNAME="$2"
        else
            APPNAME=$DEFAULT_APP
        fi
        if [ -n "$3" ]; then
            if [ "$(echo "$3" | head -c1)" = "/" ]; then
                TARGET="$3"
            else
                TARGET="$_ROOT/$3"
            fi
        fi
    fi

    # 如果app名称和对应的package名称不同，新增case即可
    case "$APPNAME" in
    $DEFAULT_APP)
        PACKAGE=$DEFAULT_PKG
        ;;
    *)
        PACKAGE=$BINAME
    esac

    PJROOT="$(dirname $ROOT)"
    CODEROOT="$PJROOT/src"
}
__softlink $0 $1 $2

# also, cross compile with env GOOS & GOARCH
if [ "$APPNAME" = "help" ]; then
    echo "Usage: $0 {package name or predefined project} [target file]"
    echo "e.g. $0 $DEFAULT_APP"
    exit 1
fi

# 检查golang环境
__check() {
    GO_DEFAULT=/usr/local/go/bin/go
    GO=go

    if ! which $GO >/dev/null ; then
        if [ -x $GO_DEFAULT ]; then
            GO=$GO_DEFAULT
        else
            echo "[Error] go environment not found" >&2
            exit 1
        fi
    fi

    if $GO mod 2>&1 | grep -q -i 'unknown command'; then
        echo "[Error] low golang version(should be >=1.11), do not support go mod command"
        exit 1
    fi
}
__check

# 搜集待注入的编译环境信息
__env() {
    cd "$PJROOT"

    VERSION="$(head -n1 "$PJROOT/version" 2>/dev/null)"
    GO_VERSION="$($GO version)"
    BUILD_RAND="$(head -c 128 /dev/urandom | hash | cut -d' ' -f1)"
    BUILD_TIME="$(date +%s)"

    if which git 2>/dev/null > /dev/null && git status 2>/dev/null >/dev/null; then
        GIT_REPO="$(git config --get remote.origin.url 2>/dev/null)"
        GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"
        GIT_HASH="$(git log -n1 --pretty=format:%H-%at 2>/dev/null)"
        GIT_NUMBER="$(git log --oneline 2>/dev/null | wc -l | awk '{print $1}')"
        GIT_STATUS_NUMBER="$(git status -s -uall 2>/dev/null | wc -l | awk '{print $1}')"
        GIT_STATUS_HASH="$(git status -s -uall 2>/dev/null | awk '{print $NF}' | xargs -I{} cat "{}" 2>/dev/null | hash | cut -d' ' -f1)"

        BUILD_INDICATOR="$(echo -n -e "$GIT_REPO\x00$GIT_BRANCH\x00$GIT_HASH\x00$GIT_NUMBER\x00$GIT_STATUS_NUMBER\x00$GIT_STATUS_HASH" | hash | cut -d' ' -f1)"
    fi
}
__env

if [ "$APPNAME" = "env" ]; then
    echo "APPNAME=$DEFAULT_APP"
    echo "VERSION=$VERSION"
    echo "GO_VERSION=$GO_VERSION"
    echo "CODEROOT=$CODEROOT"
    echo "GIT_REPO=$GIT_REPO"
    echo "GIT_HASH=$GIT_HASH"
    echo "GIT_NUMBER=$GIT_NUMBER"
    echo "GIT_STATUS_NUMBER=$GIT_STATUS_NUMBER"
    echo "GIT_STATUS_HASH=$GIT_STATUS_HASH"
    exit
fi

# 编译，使用go mod做包管理
__build() {
    cd "$CODEROOT"

    if [ ! -d "$PACKAGE" ]; then
        echo "[Error] package $PACKAGE not found"
        exit 1
    fi
    if [ ! -r go.mod ]; then
        echo "[Error] go.mod not found or not readable"
        exit 1
    fi

    _module="$(cat go.mod | grep ^module | head -n1 | awk '{print $NF}')"
    _target="$1"

    # minify binary file size, do not use if you known what you are doint
    #LDOPTIONS="-w -s"

    # disable optimization, useful for dlv debugging
    if [ -n "$flag_run" ]; then
        GCOPTIONS="all=-N -l"
    fi
    #GCOPTIONS="all=-N -l"
    $GO build -o "$_target" -gcflags="$GCOPTIONS" -ldflags "\
        $LDOPTIONS \
        -X '$_module/build.appname=$APPNAME' \
        -X '$_module/build.version=$VERSION' \
        -X '$_module/build.goVersion=$GO_VERSION' \
        -X '$_module/build.codeRoot=$CODEROOT' \
        -X '$_module/build.gitRepo=$GIT_REPO' \
        -X '$_module/build.gitBranch=$GIT_BRANCH' \
        -X '$_module/build.gitHash=$GIT_HASH' \
        -X '$_module/build.gitNumber=$GIT_NUMBER' \
        -X '$_module/build.gitStatusNumber=$GIT_STATUS_NUMBER' \
        -X '$_module/build.gitStatusHash=$GIT_STATUS_HASH' \
        -X '$_module/build.buildRand=$BUILD_RAND' \
        -X '$_module/build.buildIndicator=$BUILD_INDICATOR' \
        -X '$_module/build.buildTime=$BUILD_TIME'" ./$PACKAGE
    if [ $? -ne 0 ]; then
        exit 1
    fi
}

if [ -z "$TARGET" ]; then
    TARGET="$PJROOT/bin/$APPNAME"
    if [ -n "$GOOS" ]; then
        TARGET="$TARGET"_"$GOOS"
    fi
    if [ -n "$GOARCH" ]; then
        TARGET="$TARGET"_"$GOARCH"
    fi
fi
if ! [ -x "$TARGET" -a "$("$TARGET" version --build-indicator 2>/dev/null)" = "$BUILD_INDICATOR" ]; then
    __build "$TARGET"
fi

if [ -n "$flag_run" ]; then
    cd "$_ROOT"
    "$TARGET" $*
else
    echo "Output => $TARGET"
fi
